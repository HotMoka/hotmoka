package io.hotmoka.node.disk.internal;

import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Stream;

import io.hotmoka.node.api.requests.TransactionRequest;
import io.hotmoka.node.api.responses.TransactionResponse;
import io.hotmoka.node.api.transactions.TransactionReference;
import io.hotmoka.node.api.values.StorageReference;
import io.hotmoka.stores.AbstractStoreTransaction;
import io.hotmoka.stores.StoreException;

public class DiskStoreTransaction extends AbstractStoreTransaction<DiskStore> {
	private final ConcurrentMap<TransactionReference, TransactionRequest<?>> requests = new ConcurrentHashMap<>();
	private final ConcurrentMap<TransactionReference, TransactionResponse> responses = new ConcurrentHashMap<>();

	/**
	 * The histories of the objects created in blockchain. In a real implementation, this must
	 * be stored in a persistent state.
	 */
	private final ConcurrentMap<StorageReference, TransactionReference[]> histories = new ConcurrentHashMap<>();

	/**
	 * The errors generated by each transaction (if any). In a real implementation, this must
	 * be stored in a persistent memory such as a blockchain.
	 */
	private final ConcurrentMap<TransactionReference, String> errors = new ConcurrentHashMap<>();

	/**
	 * The storage reference of the manifest stored inside the node, if any.
	 */
	private final AtomicReference<StorageReference> manifest = new AtomicReference<>();

	public DiskStoreTransaction(DiskStore store) {
		super(store);
	}

	@Override
	public long getNow() {
		return System.currentTimeMillis();
	}

	@Override
	public Optional<TransactionResponse> getResponseUncommitted(TransactionReference reference) {
		var uncommittedResponse = responses.get(reference);
		if (uncommittedResponse != null)
			return Optional.of(uncommittedResponse);
		else
			return getStore().getResponse(reference);
	}

	@Override
	public Stream<TransactionReference> getHistoryUncommitted(StorageReference object) throws StoreException {
		var uncommittedHistory = histories.get(object);
		if (uncommittedHistory != null)
			return Stream.of(uncommittedHistory);
		else
			return getStore().getHistory(object);
	}

	@Override
	public Optional<StorageReference> getManifestUncommitted() {
		var uncommittedManifest = manifest.get();
		if (uncommittedManifest != null)
			return Optional.of(uncommittedManifest);
		else
			return getStore().getManifest();
	}

	@Override
	public DiskStore commit() throws StoreException {
		var store = getStore();

		// we report all the updates occurred during this transaction into the store
		var manifest = this.manifest.get();
		if (manifest != null)
			store.setManifest(manifest);

		for (var entry: errors.entrySet())
			store.setError(entry.getKey(), entry.getValue());

		for (var entry: histories.entrySet())
			store.setHistory(entry.getKey(), Stream.of(entry.getValue()));

		int progressive = 0;
		for (var entry: requests.entrySet())
			store.setRequest(progressive++, entry.getKey(), entry.getValue());

		progressive = 0;
		for (var entry: responses.entrySet())
			store.setResponse(progressive++, entry.getKey(), entry.getValue());

		if (progressive > 0)
			store.increaseBlockNumber();

		return store;
	}

	@Override
	public void abort() {
	}

	@Override
	protected void setRequest(TransactionReference reference, TransactionRequest<?> request) {
		requests.put(reference, request);
	}

	@Override
	protected void setResponse(TransactionReference reference, TransactionResponse response) {
		responses.put(reference, response);
	}

	@Override
	protected void setError(TransactionReference reference, String error) {
		errors.put(reference, error);
	}

	@Override
	protected void setHistory(StorageReference object, Stream<TransactionReference> history) {
		histories.put(object, history.toArray(TransactionReference[]::new));
	}

	@Override
	protected void setManifest(StorageReference manifest) {
		this.manifest.set(manifest);
	}
}