/*
Copyright 2021 Fausto Spoto

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package io.hotmoka.node.disk.internal;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Comparator;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Stream;

import io.hotmoka.annotations.ThreadSafe;
import io.hotmoka.node.NodeMarshallingContexts;
import io.hotmoka.node.NodeUnmarshallingContexts;
import io.hotmoka.node.TransactionRequests;
import io.hotmoka.node.TransactionResponses;
import io.hotmoka.node.api.requests.TransactionRequest;
import io.hotmoka.node.api.responses.TransactionResponse;
import io.hotmoka.node.api.transactions.TransactionReference;
import io.hotmoka.node.api.values.StorageReference;
import io.hotmoka.stores.Store;
import io.hotmoka.stores.StoreException;
import io.hotmoka.stores.StoreTransaction;

/**
 * The store of the memory blockchain. It is not transactional and just writes
 * everything immediately into files. It keeps responses into persistent memory,
 * while the histories are kept in RAM.
 */
@ThreadSafe
class DiskStore implements Store<DiskStore> {

	/**
	 * The histories of the objects created in blockchain. In a real implementation, this must
	 * be stored in a persistent state.
	 */
	private final ConcurrentMap<StorageReference, TransactionReference[]> histories;

	/**
	 * The errors generated by each transaction (if any). In a real implementation, this must
	 * be stored in a persistent memory such as a blockchain.
	 */
	private final ConcurrentMap<TransactionReference, String> errors;

	/**
	 * The storage reference of the manifest stored inside the node, if any.
	 */
	private final AtomicReference<StorageReference> manifest;

	private final ConcurrentMap<TransactionReference, Path> paths = new ConcurrentHashMap<>();

	/**
	 * The path where the database of the store gets created.
	 */
	private final Path dir;

	private final AtomicInteger blockNumber;

	/**
     * Creates a state for a node.
     * 
	 * @param dir the path where the database of the store gets created
     */
    DiskStore(Path dir) {
    	this.dir = dir;
    	this.histories = new ConcurrentHashMap<>();
    	this.errors = new ConcurrentHashMap<>();
    	this.manifest = new AtomicReference<>();
    	this.blockNumber = new AtomicInteger(0);
    }

    @Override
    public Optional<TransactionResponse> getResponse(TransactionReference reference) {
    	try {
    		Path path = paths.get(reference);
    		if (path == null)
    			return Optional.empty();

    		Path response = path.resolve("response");
    		try (var context = NodeUnmarshallingContexts.of(Files.newInputStream(response))) {
    			return Optional.of(TransactionResponses.from(context));
    		}
    	}
    	catch (IOException e) {
    		return Optional.empty();
    	}
    }

	@Override
	public Optional<String> getError(TransactionReference reference) {
		return Optional.ofNullable(errors.get(reference));
	}

	@Override
	public Stream<TransactionReference> getHistory(StorageReference object) {
		TransactionReference[] history = histories.get(object);
		return history == null ? Stream.empty() : Stream.of(history);
	}

	@Override
	public Optional<StorageReference> getManifest() {
		return Optional.ofNullable(manifest.get());
	}

	@Override
	public Optional<TransactionRequest<?>> getRequest(TransactionReference reference) {
		try {
			Path path = paths.get(reference);
			if (path == null)
				return Optional.empty();

			Path response = path.resolve("request");
			try (var context = NodeUnmarshallingContexts.of(Files.newInputStream(response))) {
				return Optional.of(TransactionRequests.from(context));
			}
		}
		catch (IOException e) {
			return Optional.empty();
		}
	}

	@Override
	public StoreTransaction<DiskStore> beginTransaction(long now) {
		return new DiskStoreTransaction(this);
	}

	protected void setRequest(int progressive, TransactionReference reference, TransactionRequest<?> request) throws StoreException {
		try {
			Path requestPath = getPathFor(progressive, reference, "request");
			Path parent = requestPath.getParent();
			paths.put(reference, parent);
			ensureDeleted(parent);
			Files.createDirectories(parent);
	
			Files.writeString(getPathFor(progressive, reference, "request.txt"), request.toString(), StandardCharsets.UTF_8);
	
			try (var context = NodeMarshallingContexts.of(Files.newOutputStream(requestPath))) {
				request.into(context);
			}
		}
		catch (IOException e) {
			throw new StoreException(e);
		}
	}

	protected void setResponse(int progressive, TransactionReference reference, TransactionResponse response) throws StoreException {
		try {
			Path responsePath = getPathFor(progressive, reference, "response");
			Path parent = responsePath.getParent();
			Files.createDirectories(parent);

			Files.writeString(getPathFor(progressive, reference, "response.txt"), response.toString(), StandardCharsets.UTF_8);

			try (var context = NodeMarshallingContexts.of(Files.newOutputStream(responsePath))) {
				response.into(context);
			}
		}
		catch (IOException e) {
			throw new StoreException(e);
		}
	}

	protected void setError(TransactionReference reference, String error) {
		errors.put(reference, error);
	}

	protected void setHistory(StorageReference object, Stream<TransactionReference> history) {
		histories.put(object, history.toArray(TransactionReference[]::new));
	}

	protected void setManifest(StorageReference manifest) {
		this.manifest.set(manifest);
	}

	/**
	 * Yields the path for a file inside the directory for the given transaction.
	 * 
	 * @param reference the transaction reference
	 * @param name the name of the file
	 * @return the resulting path
	 * @throws FileNotFoundException if the reference is unknown
	 */
	private Path getPathFor(int progressive, TransactionReference reference, String name) throws FileNotFoundException {
		return dir.resolve("b" + blockNumber.get()).resolve(progressive + "-" + reference).resolve(name);
	}

	/**
	 * Deletes the given directory, recursively, if it exists.
	 * 
	 * @param dir the directory
	 * @throws IOException if a disk error occurs
	 */
	private static void ensureDeleted(Path dir) throws IOException {
		if (Files.exists(dir))
			Files.walk(dir)
				.sorted(Comparator.reverseOrder())
				.map(Path::toFile)
				.forEach(File::delete);
	}

	void increaseBlockNumber() {
		blockNumber.getAndIncrement();
	}

	@Override
	public void close() {
	}
}